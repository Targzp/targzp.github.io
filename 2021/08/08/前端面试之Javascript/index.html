<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>前端面试之Javascript</title><meta name="description" content="I think,therefore I am"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/null"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="第一部分：JS基础之变量类型和计算
知识点梳理
变量类型


值类型
值类型的代码演示来分析值类型的本质
// 值类型
let a = 100
let b = a
a = 200
console.log(b) // 100


首先我们明确一点：保存原始值的变量是按值访问的，变量存储在栈空间中，我们操作的就是存储在变量中的值。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置
常见值类型： undefined、string、number、boolean、symbol


typeof 运算符（关联题目：typeof 能判断哪些类型）


识别所有值类型
let a
let str = 'abc'
let n = 100
let b = true
let s = Symbol('s')

.."><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Lawrence's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">前端面试之Javascript</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9AJS%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AE%A1%E7%AE%97"><span class="toc-text">第一部分：JS基础之变量类型和计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86"><span class="toc-text">知识点梳理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">变量类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%88%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%EF%BC%89"><span class="toc-text">深拷贝（面试常考）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E8%AE%A1%E7%AE%97"><span class="toc-text">变量计算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9AJS%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">第二部分：JS基础之原型和原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-2"><span class="toc-text">知识点梳理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#class-%E5%92%8C-%E7%BB%A7%E6%89%BF"><span class="toc-text">class 和 继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD-instanceof"><span class="toc-text">类型判断 instanceof</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">原型和原型链</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93-jQuery-%E8%80%83%E8%99%91%E6%8F%92%E4%BB%B6%E5%92%8C%E6%89%A9%E5%B1%95%E6%80%A7"><span class="toc-text">手写简易 jQuery 考虑插件和扩展性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%9AJS%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85"><span class="toc-text">第三部分：JS基础之作用域和闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-3"><span class="toc-text">知识点梳理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E8%87%AA%E7%94%B1%E5%8F%98%E9%87%8F"><span class="toc-text">作用域和自由变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#this"><span class="toc-text">this</span></a></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%20Javascript"><i class="tag post-item-tag">前端面试 Javascript</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">前端面试之Javascript</h1><time class="has-text-grey" datetime="2021-08-08T09:17:01.000Z">2021-08-08</time><article class="mt-2 post-content"><h3 id="第一部分：JS基础之变量类型和计算">第一部分：JS基础之变量类型和计算</h3>
<h4 id="知识点梳理">知识点梳理</h4>
<h5 id="变量类型">变量类型</h5>
<ul>
<li>
<p>值类型</p>
<p>值类型的代码演示来分析值类型的本质</p>
<pre><code class="language-js">// 值类型
let a = 100
let b = a
a = 200
console.log(b) // 100
</code></pre>
<p><img src="http://targzp-picture.oss-cn-beijing.aliyuncs.com/img/image-20210808174844656.png" alt="image-20210808174844656"></p>
<p>首先我们明确一点：<strong>保存原始值的变量是按值访问的</strong>，变量存储在栈空间中，我们操作的就是存储在变量中的值。<strong>在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置</strong></p>
<p>常见值类型： undefined、string、number、boolean、symbol</p>
</li>
<li>
<p>typeof 运算符（关联题目：typeof 能判断哪些类型）</p>
<ol>
<li>
<p><strong>识别所有值类型</strong></p>
<pre><code class="language-js">let a
let str = 'abc'
let n = 100
let b = true
let s = Symbol('s')

console.log(typeof a)	// undefined
console.log(typeof str) // string
console.log(typeof n)	// number
console.log(typeof b)	// boolean
console.log(typeof s)	// symbol
</code></pre>
</li>
<li>
<p><strong>识别函数</strong></p>
<pre><code class="language-js">console.log(typeof function() {})	// function
</code></pre>
</li>
<li>
<p><strong>判断是否是引用类型（不可再细分）</strong></p>
<pre><code class="language-js">console.log(typeof null)	// object
console.log(typeof ['a', 'b'])	// object
console.log(typeof { x: 100 })	// object
</code></pre>
</li>
</ol>
</li>
<li>
<p>引用类型（关联题目：值类型与引用类型的区别）</p>
<p>引用类型的代码演示来分析引用类型的本质</p>
<pre><code class="language-js">// 引用类型
let a = { age: 20 }
let b = a
b.age = 21
console.log(a.age)	// 21
</code></pre>
<p><img src="http://targzp-picture.oss-cn-beijing.aliyuncs.com/img/image-20210808174916123.png" alt="image-20210808174916123"></p>
<p><strong>引用值是保存在堆内存中的对象</strong>。JS 不允许直接访问堆内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是该对象的引用而非实际的对象本身。为此，<strong>保存引用值的变量是按引用访问的</strong></p>
<p>在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，<strong>这里复制的值实际上是一个指针，它指向存储在堆内存中的对象</strong>。操作完成后，两个变量实际上指向同一个对象，一个变量对对象的修改会在另一个变量中体现出来</p>
<p>常见值类型： object、array、null、function</p>
</li>
</ul>
<h5 id="深拷贝（面试常考）">深拷贝（面试常考）</h5>
<p>首先我们要搞清什么是浅拷贝和深拷贝</p>
<p>浅拷贝：浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，<strong>拷贝的就是内存地址</strong> ，所以<strong>如果其中一个对象改变了这个地址，就会影响到另一个对象</strong></p>
<p>深拷贝：深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且<strong>修改新对象不会影响原对象</strong>。</p>
<ul>
<li>
<p><strong>手写深拷贝</strong></p>
<p>手写深拷贝四点要注意：</p>
<ol>
<li>注意判断值类型和引用类型</li>
<li>注意判断是数组还是对象</li>
<li>注意判断属性是不是实例本身的属性</li>
<li>递归。因为属性也有可能是对象或数组</li>
</ol>
<pre><code class="language-js">/**
 * 深拷贝
 * @param {Object} obj 要拷贝的对象
 */
function deepClone(obj = {}) {
    // obj 是 null, 或者不是对象或数组, 直接返回
    if (typeof obj != 'object' || obj == null) {
        return obj
    }
    
    // 初始化返回结果
    let result
    if (obj instanceOf Array) {
        result = []
    } else {
        result = {}
    }
    
    for (let key in obj) {
        // 保证 key 不是原型的属性
        if (obj.hasOwnProperty(key)) {
            // 递归调用,因为属性也有可能是对象或数组类型
            result[key] = deepClone(obj[key])
        }
    }
    
    // 返回结果
    return result
}
</code></pre>
</li>
</ul>
<h5 id="变量计算">变量计算</h5>
<ul>
<li>
<p>类型转换</p>
<p>三处常发生的类型转换</p>
<ol>
<li>
<p><strong>字符串拼接</strong></p>
<p>如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面</p>
<p>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起</p>
<pre><code class="language-js">const a = 100 + 10	//110
const b = 100 + '10'	// '10010'
const c = true + '10'	// 'true10'
</code></pre>
</li>
<li>
<p><strong>==</strong></p>
<pre><code class="language-js">100 == '100'	//true
0 == ''			//true
0 == false		//true
false == ''		//true
null == undefined	// true
</code></pre>
<p>既然 == 运算符的类型转换情况那么多，那我们该如何记忆呢？</p>
<pre><code class="language-js">// 除 null 之外，其他一律用 ===

const obj = { x: 100 }
if (obj.a == null) {}
// 相当于
if (obj.a === null || obj.a === undefined) {}
</code></pre>
</li>
<li>
<p><strong>if 语句和逻辑运算</strong></p>
<p><strong>truly 变量</strong>：<code>!!a === true</code> 的变量</p>
<p><strong>falsely 变量</strong>：<code>!!a === false</code> 的变量</p>
<pre><code class="language-js">// 以下是 falsely 变量.除此之外都是 truly 变量
!!0 === false
!!NaN === false
!!'' === false
!!null === false
!!undefined === false
!!false === false
</code></pre>
<p><strong>if 语句判断的就是 truly 变量和 falsely 变量</strong></p>
<pre><code class="language-js">// truly 变量
const a = true
if (a) {
    // ...
}

const b = 100
if (b) {
    // ...
}

// falsely 变量
const c = ''
if (c) {
    // ...
}

const d = null
if (d) {
    // ...
}

let e	// 未初始化,默认为 undefined
if (e) {
    // ...
}
</code></pre>
<p>逻辑运算</p>
<pre><code class="language-js">console.log(10 &amp;&amp; 0)	// 0,因为 0 是 falsely 变量,直接返回
console.log('abc' || '')	// 'abc',因为 'abc' 是 truly 变量,直接返回
console.log(!window.abc)	// true
</code></pre>
</li>
</ol>
</li>
</ul>
<h3 id="第二部分：JS基础之原型和原型链">第二部分：JS基础之原型和原型链</h3>
<h4 id="知识点梳理-2">知识点梳理</h4>
<h5 id="class-和-继承">class 和 继承</h5>
<ul>
<li>
<p>class 的基本使用</p>
<pre><code class="language-js">// 类
class Student {
    // 通过 constructor 类构造函数来进行实例化
    constructor (name, number) {
        this.name = name
        this.number = number
    }

    sayHi () {
        console.log(
            `姓名：${this.name} 学号：${this.number}`
        )
    }
}

// 通过类 new 对象/实例
const xialuo = new Student('夏洛', 23)
xialuo.sayHi()

const madongmei = new Student('马冬梅', 23)
madongmei.sayHi()
</code></pre>
</li>
<li>
<p>继承</p>
<pre><code class="language-js">// 父类
class People {
    constructor (name) {
        this.name = name
    }

    eat(){
        console.log(`${this.name} is Eating...`)
    }
}

// 子类 通过 extends 来继承父类 People
class Student extends People {
    constructor (name, number) {
        // 通过 super 来调用父类类构造函数，并返回实例
        super(name)
        this.number = number
    }

    sayHi () {
        console.log(
            `姓名：${this.name} 学号：${this.number}`
        )
    }
}

// 子类
class Teacher extends People {
    constructor (name, major) {
        super(name)
        this.major = major
    }
    teach () {
        console.log(
            `姓名：${this.name} 教授课程：${this.major}`
        )
    }
}

// 学生实例
const xialuo = new Student('夏洛', 233)
xialuo.sayHi()
xialuo.eat()

// 老师实例
const wanglaoshi = new Teacher('王老师', '语文')
wanglaoshi.teach()
wanglaoshi.eat()

console.log(wanglaoshi)
</code></pre>
</li>
</ul>
<h5 id="类型判断-instanceof">类型判断 instanceof</h5>
<p>我们可以通过 instanceof 关键字<strong>来判断对象/实例属不属于指定类</strong></p>
<pre><code class="language-js">xialuo instanceof Student // true
xialuo instanceof People // true
xialuo instanceof object // true

[] instanceof Array // true
[] instanceof Object // true

{} instanceof Object // true
</code></pre>
<h5 id="原型和原型链">原型和原型链</h5>
<ul>
<li>
<p>原型</p>
<pre><code class="language-js">// class 实际上是函数，可见时语法糖
typeof People // 'function'
typeof Student // 'function'

// 隐式原型和显示原型
console.log(xiaoluo.__proto__)
console.log(Student.prototype)
console.log(xialuo.__proto__ === Student.prototype)
</code></pre>
<p><img src="http://targzp-picture.oss-cn-beijing.aliyuncs.com/img/image-20210811175324422.png" alt="image-20210811175324422"></p>
<ul>
<li>原型关系
<ol>
<li><strong>每个 class 都有显示原型 prototype</strong></li>
<li><strong>每个实例都有隐式原型 __ proto __</strong></li>
<li><strong>实例的 __ proto __ 指向对应 class 的 prototype</strong></li>
</ol>
</li>
<li>基于原型的执行规则
<ol>
<li><strong>获取属性 <a target="_blank" rel="noopener" href="http://xialuo.name">xialuo.name</a> 或执行方法 xialuo.sayhi() 时</strong></li>
<li><strong>先在自身属性和方法寻找</strong></li>
<li><strong>如果找不到则自动去 __ proto __ 中查找</strong></li>
</ol>
</li>
</ul>
</li>
<li>
<p>原型链</p>
<pre><code class="language-js">console.log(Student.prototype.__proto__)
console.log(People.prototype)
console.log(People.prototype === Student.prototype.__proto__)
</code></pre>
<p><img src="http://targzp-picture.oss-cn-beijing.aliyuncs.com/img/image-20210811195802980.png" alt="image-20210811195802980"></p>
<p><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>每一个对象/实例都有一个 隐式原型 __ proto__ 指向构造它的类的 显式原型 prototype（<strong>隐式原型其实就是显式原型的一个指针</strong>）。而这个类又是某个某个类的子类，那么这个类的显式原型上有一个隐式原型指向这个类的父类的显式原型。那么这样一种解 构，我们称作原型链</p>
<p>其实子类继承于父类，子类的原型可以看作是父类的一个实例，但又不完全是（因为没有实例属性），因为只有实例才有隐式原型指向构造它的类的显式原型</p>
<p>那么一个对象的属性查找，就是沿着这条原型链进行查找的。instanceof 操作符就是检查该对象的原型链上有没有指定类型的原型</p>
</li>
</ul>
<h5 id="手写简易-jQuery-考虑插件和扩展性">手写简易 jQuery 考虑插件和扩展性</h5>
<pre><code class="language-js">class jQuery {
    constructor (selector) {
        const result = document.querySelectorAll(selector)
        const length = result.length
        for (let i = 0; i &lt; length; i++) {
            this[i] = result[i]
        }
        this.length = length
        this.selector = selector
        // 类数组对象
    }

    get (index) {
        return this[index]
    }

    each (fn) {
        for (let i = 0; i &lt; this.length; i++) {
            const elem = this[i]
            fn(elem)
        }
    }

    on (type, fn) {
        return this.each(elem =&gt; {
            elem.addEventListener(type, fn, false)
        })
    }

    // 扩展很多 DOM API
}

// 插件 在原型上去扩展方法
jQuery.prototype.dialog = function (info) {
    alert(info)
}

// 造轮子 继承 jQuery 类去扩展自己的方法和属性, 那么以后只要使用这个子类就行了
class myJQuery extends jQuery {
    constructor (selector) {
        super(selector)
    }
    // 扩展自己的方法
    addClass (className) {
        ...
    }
}
</code></pre>
<h3 id="第三部分：JS基础之作用域和闭包">第三部分：JS基础之作用域和闭包</h3>
<h4 id="知识点梳理-3">知识点梳理</h4>
<h5 id="作用域和自由变量">作用域和自由变量</h5>
<ul>
<li>
<p>作用域</p>
<img src="http://targzp-picture.oss-cn-beijing.aliyuncs.com/img/image-20210812172222690.png" alt="image-20210812172222690" style="zoom:50%;">
<p><strong>作用域代表了变量合法的使用范围</strong>，如果变量在范围之外去使用，则会报错</p>
<p>作用域分类</p>
<ul>
<li>
<p>全局作用域</p>
</li>
<li>
<p>函数作用域</p>
</li>
<li>
<p>块级作用域</p>
<pre><code class="language-js">// 块级作用域
if (true) {
    let x = 100
}

console.log(x) // 会报错
</code></pre>
</li>
</ul>
</li>
<li>
<p>自由变量</p>
<p>一个变量在当前作用域没有定义，但被使用了</p>
<p>向上级作用域，一层一层依次寻找，直至找到为止</p>
<p>如果到全局作用域都没找到，则报错</p>
</li>
</ul>
<h5 id="闭包">闭包</h5>
<p>何为闭包？如果不死扣概念和底层逻辑，其实是作用域应用的特殊情况，有两种表现：</p>
<ol>
<li><strong>函数作为参数被传递</strong></li>
<li><strong>函数作为返回值被返回</strong></li>
</ol>
<p>总而言之，<strong>只要函数定义的地方和函数执行的地方不一样，都会产生闭包，我们近乎可以把这个函数称作闭包</strong></p>
<p>以下是针对上面两种表现的实际例子：</p>
<pre><code class="language-js">// 函数作为返回值
function create () {
    let a = 100
    return function () {
        console.log(a)
    }
}

let fn = create()
let a = 200
fn()   // 100
</code></pre>
<pre><code class="language-js">// 函数作为参数被传递
function print (fn) {
    let a = 200
    fn()
}
let a = 100
function fn () {
    console.log(a)
}
print(fn)   // 100
</code></pre>
<p>注意，**所有的自由变量的查找，是在函数定义的地方，向上级作用域查找，不是在执行的地方！**这一点在闭包中尤为明显</p>
<p>以上对于闭包的描述并没有太深入，只是引入了闭包常见的使用场景。接下来我们引入作用域链及执行上下文来总结描述以下闭包的基本原理：</p>
<ol>
<li>首先，只要我们定义了一个函数，在预编译阶段就会为它创建作用域链，并且预装载包含上下文的活动对象及全局变量对象，并把这个作用域链保存在内部的 [[Scope]] 中</li>
<li>如若外部函数将内部定义的函数作为函数值返回，它的执行上下文就会从执行上下文栈中弹出，但是它的活动对象却保留了下来，<strong>因为内部定义的函数的作用域链上还保留着对它的引用</strong>（这时候产生了闭包）</li>
<li>此时这个被返回的函数被调用，在创建执行上下文阶段，会通过复制函数的 [[Scope]] 来创建作用域链，接着会创建函数的活动对象并将其推入作用链的前端。然后在执行阶段查找变量时，会先从自身活动对象上查找，再根据作用域链，从包含上下文的活动对象上查找，直至全局变量对象</li>
</ol>
<p>只要在一个函数中定义了一个内部函数，且内部函数使用了外部函数的变量（称之为自由变量），外部函数将这个内部函数作为返回值返回，这种情况，就会产生闭包！</p>
<h5 id="this">this</h5>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2021/08/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8BHTML/" title="前端面试之HTML"><span class="has-text-weight-semibold">Next: 前端面试之HTML</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Targzp/targzp.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Targzp"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Lawrence 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>