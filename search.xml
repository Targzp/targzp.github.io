<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端面试之Javascript</title>
      <link href="/2021/08/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8BJavascript/"/>
      <url>/2021/08/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8BJavascript/</url>
      
        <content type="html"><![CDATA[<h3 id="第一部分：JS基础之变量类型和计算">第一部分：JS基础之变量类型和计算</h3><h4 id="知识点梳理">知识点梳理</h4><h5 id="变量类型">变量类型</h5><ul><li><p>值类型</p><p>值类型的代码演示来分析值类型的本质</p><pre><code class="language-js">// 值类型let a = 100let b = aa = 200console.log(b) // 100</code></pre><p><img src="http://targzp-picture.oss-cn-beijing.aliyuncs.com/img/image-20210808174844656.png" alt="image-20210808174844656"></p><p>首先我们明确一点：<strong>保存原始值的变量是按值访问的</strong>，变量存储在栈空间中，我们操作的就是存储在变量中的值。<strong>在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置</strong></p><p>常见值类型： undefined、string、number、boolean、symbol</p></li><li><p>typeof 运算符（关联题目：typeof 能判断哪些类型）</p><ol><li><p><strong>识别所有值类型</strong></p><pre><code class="language-js">let alet str = 'abc'let n = 100let b = truelet s = Symbol('s')console.log(typeof a)// undefinedconsole.log(typeof str) // stringconsole.log(typeof n)// numberconsole.log(typeof b)// booleanconsole.log(typeof s)// symbol</code></pre></li><li><p><strong>识别函数</strong></p><pre><code class="language-js">console.log(typeof function() {})// function</code></pre></li><li><p><strong>判断是否是引用类型（不可再细分）</strong></p><pre><code class="language-js">console.log(typeof null)// objectconsole.log(typeof ['a', 'b'])// objectconsole.log(typeof { x: 100 })// object</code></pre></li></ol></li><li><p>引用类型（关联题目：值类型与引用类型的区别）</p><p>引用类型的代码演示来分析引用类型的本质</p><pre><code class="language-js">// 引用类型let a = { age: 20 }let b = ab.age = 21console.log(a.age)// 21</code></pre><p><img src="http://targzp-picture.oss-cn-beijing.aliyuncs.com/img/image-20210808174916123.png" alt="image-20210808174916123"></p><p><strong>引用值是保存在堆内存中的对象</strong>。JS 不允许直接访问堆内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是该对象的引用而非实际的对象本身。为此，<strong>保存引用值的变量是按引用访问的</strong></p><p>在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，<strong>这里复制的值实际上是一个指针，它指向存储在堆内存中的对象</strong>。操作完成后，两个变量实际上指向同一个对象，一个变量对对象的修改会在另一个变量中体现出来</p><p>常见值类型： object、array、null、function</p></li></ul><h5 id="深拷贝（面试常考）">深拷贝（面试常考）</h5><p>首先我们要搞清什么是浅拷贝和深拷贝</p><p>浅拷贝：浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，<strong>拷贝的就是内存地址</strong> ，所以<strong>如果其中一个对象改变了这个地址，就会影响到另一个对象</strong></p><p>深拷贝：深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且<strong>修改新对象不会影响原对象</strong>。</p><ul><li><p><strong>手写深拷贝</strong></p><p>手写深拷贝四点要注意：</p><ol><li>注意判断值类型和引用类型</li><li>注意判断是数组还是对象</li><li>注意判断属性是不是实例本身的属性</li><li>递归。因为属性也有可能是对象或数组</li></ol><pre><code class="language-js">/** * 深拷贝 * @param {Object} obj 要拷贝的对象 */function deepClone(obj = {}) {    // obj 是 null, 或者不是对象或数组, 直接返回    if (typeof obj != 'object' || obj == null) {        return obj    }        // 初始化返回结果    let result    if (obj instanceOf Array) {        result = []    } else {        result = {}    }        for (let key in obj) {        // 保证 key 不是原型的属性        if (obj.hasOwnProperty(key)) {            // 递归调用,因为属性也有可能是对象或数组类型            result[key] = deepClone(obj[key])        }    }        // 返回结果    return result}</code></pre></li></ul><h5 id="变量计算">变量计算</h5><ul><li><p>类型转换</p><p>三处常发生的类型转换</p><ol><li><p><strong>字符串拼接</strong></p><p>如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面</p><p>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起</p><pre><code class="language-js">const a = 100 + 10//110const b = 100 + '10'// '10010'const c = true + '10'// 'true10'</code></pre></li><li><p><strong>==</strong></p><pre><code class="language-js">100 == '100'//true0 == ''//true0 == false//truefalse == ''//truenull == undefined// true</code></pre><p>既然 == 运算符的类型转换情况那么多，那我们该如何记忆呢？</p><pre><code class="language-js">// 除 null 之外，其他一律用 ===const obj = { x: 100 }if (obj.a == null) {}// 相当于if (obj.a === null || obj.a === undefined) {}</code></pre></li><li><p><strong>if 语句和逻辑运算</strong></p><p><strong>truly 变量</strong>：<code>!!a === true</code> 的变量</p><p><strong>falsely 变量</strong>：<code>!!a === false</code> 的变量</p><pre><code class="language-js">// 以下是 falsely 变量.除此之外都是 truly 变量!!0 === false!!NaN === false!!'' === false!!null === false!!undefined === false!!false === false</code></pre><p><strong>if 语句判断的就是 truly 变量和 falsely 变量</strong></p><pre><code class="language-js">// truly 变量const a = trueif (a) {    // ...}const b = 100if (b) {    // ...}// falsely 变量const c = ''if (c) {    // ...}const d = nullif (d) {    // ...}let e// 未初始化,默认为 undefinedif (e) {    // ...}</code></pre><p>逻辑运算</p><pre><code class="language-js">console.log(10 &amp;&amp; 0)// 0,因为 0 是 falsely 变量,直接返回console.log('abc' || '')// 'abc',因为 'abc' 是 truly 变量,直接返回console.log(!window.abc)// true</code></pre></li></ol></li></ul><h3 id="第二部分：JS基础之原型和原型链">第二部分：JS基础之原型和原型链</h3><h4 id="知识点梳理-2">知识点梳理</h4><h5 id="class-和-继承">class 和 继承</h5><h5 id="类型判断-instanceof">类型判断 instanceof</h5><h5 id="原型和原型链">原型和原型链</h5>]]></content>
      
      
      
        <tags>
            
            <tag> 前端面试 Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试之HTML</title>
      <link href="/2021/08/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8BHTML/"/>
      <url>/2021/08/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8BHTML/</url>
      
        <content type="html"><![CDATA[<h4 id="第一题：如何理解-HTML-语义化？">第一题：如何理解 HTML 语义化？</h4><ul><li><p>明确 HTML 语义化所带来的<strong>好处</strong></p><ol><li><p>让人更容易读懂（<strong>增加代码可读性</strong>）</p></li><li><p>让搜索引擎更容易读懂（<strong>SEO，即搜索引擎优化</strong>）</p><p>搜索引擎能根据语义化的标签来解析你的整个网页，弄清主次关系，提取重点内容，最后展示给用户</p></li></ol></li></ul><h4 id="第二题：哪些是块状元素，哪些是内联元素">第二题：哪些是块状元素，哪些是内联元素</h4><ul><li><p>display: block/table；有 div h1 h2 table ul ol p 等</p><p><strong>块状元素独占一行，默认垂直向下进行排布</strong></p></li><li><p>display: inline/inline-block；有 span img input button 等</p><p><strong>内联元素不会独占一行</strong>，默认紧挨着进行排布直到容器边缘为止进行换行</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端面试 HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试之CSS</title>
      <link href="/2021/08/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8BCSS/"/>
      <url>/2021/08/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8BCSS/</url>
      
        <content type="html"><![CDATA[<p><img src="http://targzp-picture.oss-cn-beijing.aliyuncs.com/img/css.jpg" alt="css"></p><blockquote><p>前端面试系列主要是针对前端各个技术面试时常见的面试问题和知识点的整理。属于面试向的博文，所以较为零碎和不全面，请悉知</p></blockquote><p><strong>首先我们可以看一下 CSS 面试题的知识模块</strong></p><p><img src="http://targzp-picture.oss-cn-beijing.aliyuncs.com/img/image-20210808112454023.png" alt="image-20210808112454023"></p><h3 id="CSS-知识点梳理">CSS 知识点梳理</h3><h4 id="第一部分：布局">第一部分：布局</h4><h5 id="盒模型宽度计算"><strong>盒模型宽度计算</strong></h5><p>先看例题</p><p><img src="http://targzp-picture.oss-cn-beijing.aliyuncs.com/img/image-20210809114616843.png" alt="image-20210809114616843"></p><p>首先，什么是 offsetWidth？ <strong>offsetWidth = (内容宽度 + 内边距 + 边框) 无外边距</strong>。因此上面的答案是 122 px</p><p>那么如果让 offsetWidth 等于 100px，该如何去做呢？上面的 width 默认设定的是内容宽度。我们可以使用 box-sizing 属性去改变这个默认设定</p><p><img src="http://targzp-picture.oss-cn-beijing.aliyuncs.com/img/image-20210809115044825.png" alt="image-20210809115044825"></p><p>我们把 box-sizing 的值设为 border-box，<strong>让 width 设定的宽度为 到边框外边界的 宽度</strong>，这样这里的内容宽度就会自动去计算。offsetWidth 的宽度相当于 width 设定的宽度</p><h5 id="margin-纵向重叠问题"><strong>margin 纵向重叠问题</strong></h5><p>首先来开例题</p><p><img src="http://targzp-picture.oss-cn-beijing.aliyuncs.com/img/image-20210809120347064.png" alt="image-20210809120347064"></p><p>我们知道，<strong>相邻块级元素的 margin-top 和 margin-bottom 为发生重叠</strong>。空白内容的 p 元素也会重叠，这里进行了多层重叠，所以看上去这三个 p 元素被忽略了一样。这里要补充一下重叠的简单过程的通俗理解，两个外边距进行重叠，<strong>谁先触碰到对方外边距内边界谁就胜出</strong>，那么两个元素的距离就由谁说了算。所以答案是 15px</p><h5 id="margin-负值问题"><strong>margin 负值问题</strong></h5><p><img src="http://targzp-picture.oss-cn-beijing.aliyuncs.com/img/image-20210810110640470.png" alt="image-20210810110640470"></p><h5 id="BFC-理解与应用"><strong>BFC 理解与应用</strong></h5><ul><li><p>BFC 理解</p><p>Block format context  块级格式化上下文</p><p><strong>一块独立的渲染区域，内部元素的渲染不会影响边界以外的元素</strong></p></li><li><p>形成 BFC 的常见条件</p><p>float 不是 none</p><p><strong>position 是 absolute 或 fixed</strong></p><p><strong>overflow 不是 visible</strong></p><p><strong>display 是 flex inline-block 等</strong></p></li><li><p>BFC 常见应用</p><p><strong>BFC 清除浮动</strong></p><pre><code class="language-html">&lt;style&gt;    .BFC{        width: 100%;        background: #beace9;        overflow: hidden;   /* 触发元素 BFC */    }    .inner{        width: 100px;        height: 100px;        background: #e6e6a3;        float: left;    }&lt;/style&gt;&lt;div class="BFC"&gt;    这是 BFC 示例    &lt;div class="inner"&gt;我是浮动元素&lt;/div&gt;&lt;/div&gt;</code></pre><p>看图例，这是没有触发 BFC 的时候</p><p><img src="http://targzp-picture.oss-cn-beijing.aliyuncs.com/img/image-20210810113910661.png" alt="image-20210810113910661"></p><p>浮动元素脱离文档流造成父元素高度塌陷，致使影响到外部元素。下面是使用 overflow: hidden 触发 BFC 的图例</p><p><img src="http://targzp-picture.oss-cn-beijing.aliyuncs.com/img/image-20210810114047409.png" alt="image-20210810114047409"></p><p>触发 BFC 后，父元素高度会被撑开，高度包含浮动元素的高度。<strong>因为根据 BFC 的基本布局规则，BFC 内部的子元素不会影响到外部元素，且 float 元素的高度算在 BFC 的高度内</strong></p></li></ul><h5 id="float-布局"><strong>float 布局</strong></h5><p>float 布局两个重要的知识点</p><ul><li><p>如何实现<strong>圣杯布局和双飞翼布局</strong></p><p><img src="http://targzp-picture.oss-cn-beijing.aliyuncs.com/img/image-20210810114635603.png" alt="image-20210810114635603"></p><p><img src="http://targzp-picture.oss-cn-beijing.aliyuncs.com/img/image-20210810115039556.png" alt="image-20210810115039556"></p><p>圣杯布局代码实现：</p><pre><code class="language-html">&lt;style&gt;    body {        min-width: 550px;    }    #header {        text-align: center;        background-color: #f1f1f1;    }    .column {        float: left;    }    #container {        padding: 0 150px 0 200px;    }    #center {        background-color: #ccc;        width: 100%;    }    #left {        position: relative;        background-color: yellow;        width: 200px;        margin-left: -100%;        right: 200px;    }    #right {        background-color: red;        width: 150px;        margin-right: -150px;    }    #footer {        text-align: center;        background-color: #f1f1f1;    }    /* 手写 clearfix */    .clearfix::after {        content: '';        display: table;        clear: both;    }&lt;/style&gt;&lt;body&gt;    &lt;div id="header"&gt;this is header&lt;/div&gt;    &lt;div id="container" class="clearfix"&gt;        &lt;div id="center" class="column"&gt;this is center&lt;/div&gt;        &lt;div id="left" class="column"&gt;this is left&lt;/div&gt;        &lt;div id="right" class="column"&gt;this is right&lt;/div&gt;    &lt;/div&gt;    &lt;div id="footer"&gt;this is footer&lt;/div&gt;&lt;/body&gt;</code></pre><p><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 实现过程：</p><ol><li>html 部分主要是一个容器元素内有三个实现浮动的元素。两边要设置固定宽度，中间宽度为 100%</li><li>容器元素设置其 padding 值，padding 值为两侧浮动元素的宽度</li><li>左侧浮动元素设置其 margin-left 值，值为 -100%，也就是说向左偏移相当于容纳块的宽度。此时还没有到达它的真正位置。所以要使用 <code>position: relative</code> 相对于自身右侧偏移，偏移量为自身宽度</li><li>右侧浮动元素设置其 margin-right 值，值为负的自身宽度，也就是从右侧向内收缩自身宽度的量，导致其宽度从布局上被忽略，故而向上浮动到中间浮动元素的右侧</li></ol><p>最终效果</p><p><img src="http://targzp-picture.oss-cn-beijing.aliyuncs.com/img/image-20210811113924148.png" alt="image-20210811113924148"></p><p>双飞翼布局代码实现：</p><pre><code class="language-html">&lt;style&gt;    body {        min-width: 550px;    }    .col {        float: left;    }    #main {        background-color: #ccc;        width: 100%;        height: 200px;    }    #main &gt; #main-wrap {        margin: 0 190px;    }    #left {        background-color: #0000FF;        width: 190px;        height: 200px;        margin-left: -100%;    }    #right {        background-color: #FF0000;        width: 190px;        height: 200px;        margin-left: -190px;    }&lt;/style&gt;&lt;body&gt;    &lt;div id="main" class="col"&gt;        &lt;div id="main-wrap"&gt;            this is main        &lt;/div&gt;    &lt;/div&gt;    &lt;div id="left" class="col"&gt;        this is left    &lt;/div&gt;    &lt;div id="right" class="col"&gt;        this is right    &lt;/div&gt;&lt;/body&gt;</code></pre><p><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 实现过程：</p><ol><li>html 部分主要是实现浮动的三个元素（亦可包含在一个容器元素中），<strong>不过中间浮动元素的内容部分另外包装在一个元素中</strong></li><li>给中间浮动元素中包装内容的元素设置左右 margin，值为两侧浮动元素的宽度</li><li>左侧浮动元素设置 margin-left，值为 -100%。这里就不用设置 <code>position: relative</code> 了</li><li>右侧浮动元素设置 margin-left（注意，不是 margin-right，因为容器元素并未 padding 或 margin，很可能导致右侧浮动元素超出页面部分），值为负的自身宽度</li></ol><p>最终效果：</p><p><img src="http://targzp-picture.oss-cn-beijing.aliyuncs.com/img/image-20210811114812928.png" alt="image-20210811114812928"></p></li></ul><h5 id="手写-clearfix">手写 <strong>clearfix</strong></h5><p>代码演示：</p><pre><code class="language-css">/* 手写 clearfix */.clearfix::after {    content: '';    display: table;    clear: both;}</code></pre><p>为什么要使用 clearfix，我想这篇文章写的很好：<a href="https://www.jianshu.com/p/9d6a6fc3e398">https://www.jianshu.com/p/9d6a6fc3e398</a></p><p>总而言之，相比使用 <code>clear: both</code> 来清除浮动，<strong>使用 clearfix 这种清除浮动的方法，可以同时撑开浮动元素容器的高度</strong>。添加伪元素 ::after 其实是在元素后面添加了一个元素，在这个伪元素上使用了 <code>clear: both</code> 使其清除两边浮动元素，故而使也能使容器高度撑开</p><h5 id="flex-布局">flex 布局</h5><ul><li><p>常用语法回顾</p><ul><li>flex-direction：主轴方向</li><li>justify-content：弹性元素行中主轴对齐方式</li><li>align-items：弹性元素行中垂轴对齐方式</li><li>flex-wrap：是否允许换行</li><li>align-self：弹性元素自身垂轴对齐方式</li></ul></li><li><p>用 flex 画一个三点色子</p><p>代码演示</p><pre><code class="language-html">&lt;style&gt;    /* flex 画三个点的色子 */    .box {        display: flex;  /* flex 布局 */        justify-content: space-between; /* 两端对齐 */        width: 500px;        height: 500px;        padding: 50px;        border: 1px solid #ccc;        border-radius: 20px;    }    /* 点的背景色、大小、边框等 */    .dot {        width: 80px;        height: 80px;        border-radius: 50%;        background-color: #000;    }    /* 第二项居中对齐 */    .dot:nth-child(2) {        align-self: center;    }    /* 第三项尾对齐 */    .dot:nth-child(3) {        align-self: flex-end;    }&lt;/style&gt;&lt;body&gt;    &lt;div class="box"&gt;        &lt;div class="dot"&gt;&lt;/div&gt;        &lt;div class="dot"&gt;&lt;/div&gt;        &lt;div class="dot"&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><p>最终效果：</p><img src="http://targzp-picture.oss-cn-beijing.aliyuncs.com/img/image-20210811122631350.png" alt="image-20210811122631350" style="zoom:50%;"></li></ul><h3 id="CSS-题目整理">CSS 题目整理</h3><h4 id="第一题：CSS-伪类与伪元素的区别">第一题：CSS 伪类与伪元素的区别</h4><ul><li><p>伪类</p><p>利用伪类可以<strong>为文档中不一定真实存在的结构指定样式，或者为某些元素（甚至文档本身）的特定状态赋予幽灵类</strong></p><p>由于状态的变化是⾮静态的，所以元素达到⼀个特定状态时，它可能得到⼀个伪类的样式；当状态改变时，它⼜会失去这个样式</p><p>由此可以看出，它的功能和class有些类似，但它是<strong>基于⽂档之外的抽象</strong>，所以叫 伪类</p></li><li><p>伪元素</p><p>顾名思义就是 <strong>DOM 树中没有定义的虚拟元素</strong></p><p>核心就是需要创建通常不存在于文档中的元素</p><p>⽐如::before ::after 它选择的是元素指定内容，表示选择元素内容的之前内容或之后内容</p><p>伪元素控制的内容和元素是没有差别的，但是它本身只是<strong>基于元素的抽象</strong>，并不存在于⽂档中，所以称为伪元素。⽤于将特殊的效果添加到某些选择器</p></li><li><p>伪类与伪元素的区别</p><p>表示不同：伪类以 : 开头，伪元素以 :: 开头</p><p>定义不同：伪类即假的类，可以添加类达到效果；伪元素即假元素，需要通过添加元素才能达到效果</p></li></ul><h4 id="第二题：说一下盒模型，以及标准模型和-IE-模型">第二题：说一下盒模型，以及标准模型和 IE 模型</h4><ul><li><p>什么是盒模型</p><p>盒模型是 css 中一种非常基础的设计模式，<strong>web 页面中每一个元素都可以当作一个盒模型</strong>，每一个盒模型都是由 display、position、float、width、height、padding、border、margin 等属性组合构成。<strong>不同类型的盒模型在页面布局上及表现上都不同</strong>。css 中主要有 inline、inline-block、block、absolute position、float 等类型</p></li><li><p>W3C 标准模型和 IE 传统模型</p><p>标准模型： height / width（空间高度 / 宽度）= 内容高度 / 宽度 + 内边距 + 边框宽度 + 外边距 【height / width 为 内容高度 / 宽度】</p><p>IE 模型： height / width （空间高度 / 宽度） =  内容高度 / 宽度 + 外边距【height / width 包含了 内容高度 / 宽度、边框宽度、内边距】</p></li><li><p>CSS 如何设置标准模型和 IE 模型</p><p><strong>利用 box-sizing 属性</strong>： content-box 为标准模型；border-box 为 IE 模型</p></li></ul><h4 id="第三题：-BFC-是什么？触发-BFC-的条件是什么？有哪些应用场景？">第三题： BFC 是什么？触发 BFC 的条件是什么？有哪些应用场景？</h4><ul><li><p>概念</p><p>BFC（Box Formatting context）：Box 是 CSS 布局的对象和基本单位。<strong>BFC 就是页面上的一个隔离的独立容器</strong>。<strong>容器里面的子元素不会影响到外面的元素。反之也如此</strong></p><p>块级格式化上下文布局规则：</p><ul><li>内部的 BOX 会在垂直方向一个接一个的放置</li><li>属于同一个 BFC 的两个相邻 Box 的 margin 会重叠；不同 BFC 就不会</li><li>是页面上一个隔离的独立容器，里面的元素不会影响到外面的元素；反之亦然</li><li>BFC 的区域不会和 float box 重叠</li><li><strong>计算 BFC 的高度，浮动元素也参与计算</strong></li></ul></li><li><p>触发条件</p><p>触发条件简要概括：</p><ul><li>根元素</li><li>float 属性不为 none</li><li>position 为 absolute 或 fixed</li><li><strong>overflow 不为 visible</strong></li><li>display 为 inline-block、table-cell、table-caption、flex、inline-flex</li></ul></li><li><p>应用场景</p><ol><li><p>清除内部的浮动，触发父元素的 BFC 属性，会包含 float 元素</p><p><strong>防止浮动导致父元素高度塌陷父级设置 overflow: hidden</strong>， 元素 float: left;</p></li><li><p><strong>分属于不同的 BFC，可以阻止 Margin 重叠</strong></p><p>避免 margin 重叠，两个块相邻就会导致外边距被折叠，给中间的设置 BFC 就会避免，方法就是套个父级设置 overflow: hidden</p></li><li><p>阻止元素被浮动元素覆盖，各自是独立的渲染区域</p></li><li><p>自适应两栏布局</p></li></ol></li></ul><h4 id="第四题：说一下什么是重绘重排，哪些操作会造成重绘重排">第四题：说一下什么是重绘重排，哪些操作会造成重绘重排</h4><ul><li><p>什么是重绘重排</p><p>当我们改变了一个元素<strong>尺寸位置属性</strong>时，会重新进行样式计算、布局绘制以及后面的所有流程，这种行为称为 <strong>重排</strong></p><p>当改变了某个元素的颜色属性是不会重新触发布局，但还是会<strong>触发样式计算和绘制</strong>这就是 <strong>重绘</strong></p><p>我们可以发现<strong>重排和重绘都会占用主线程，还有 JS 也会运行在主线程</strong>，所以就会出现抢占执行时间的问题，如果你写了一个不断导致重排重绘的动画，浏览器则需要在每一帧都运行样式计算布局和绘制的操作</p></li><li><p>触发的一些因素</p><ul><li>页面首次进入的渲染</li><li>浏览器 resize</li><li>元素位置和尺寸发生改变的时候</li><li>可见元素的增删</li><li>内容发生改变</li><li>css 伪类激活</li></ul></li><li><p>如何优化</p><p>CSS 中有个动画属性 transform，<strong>通过该属性实现的动画不会经过布局和绘制，而是直接运行在合成器线程和栅格线程</strong>，所以不会受到主线程中 js 执行的影响。更重要的是经过 transform 实现的动画由于不需要经过布局绘制样式计算等操作，所以节省了很多运算时间</p></li></ul><h4 id="第五题：使用-CSS-实现一个水波纹的效果">第五题：使用 CSS 实现一个水波纹的效果</h4><pre><code class="language-html">&lt;style&gt;    .wave-content {        position: relative;        width: 400px;        height: 400px;        margin: 100px 0 0 100px;    }    .wave{        width: 100%;        height: 100%;        position: absolute;        opacity: 0;        transform-origin: center center;        border: 1px solid black;        border-radius: 50%;        animation-name: wave;        animation-duration: 7s;        animation-timing-function: linear;        animation-iteration-count: infinite;    }    .wave1 {        animation-delay: 0s;    }    .wave2 {        animation-delay: 1.5s;    }    .wave3 {        animation-delay: 3s;    }    .wave4 {        animation-delay: 4.5s;    }    @keyframes wave {        0% {            opacity: 0;            transform: scale(0.5);        }        30% {            opacity: 0.7;            transform: scale(0.65);        }        70% {            opacity: 0.1;            transform: scale(0.85);        }        100% {            opacity: -0.2;            transform: scale(1);        }    }&lt;/style&gt;&lt;body&gt;    &lt;div class="wave-content "&gt;        &lt;div class="wave wave1 "&gt;&lt;/div&gt;        &lt;div class="wave wave2 "&gt;&lt;/div&gt;        &lt;div class="wave wave3 "&gt;&lt;/div&gt;        &lt;div class="wave wave4"&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><h4 id="第六题：position-定位都有什么属性（不仅仅是绝对定位和相对定位-fix-定位）">第六题：position 定位都有什么属性（不仅仅是绝对定位和相对定位/ fix 定位）</h4><ul><li><p>position 概念</p><p><strong>position 属性把元素放置到一个静态的、相对的、绝对的、或固定的位置中</strong></p></li><li><p>position 属性值</p><p>position 属性值共有四个常用的：static、relative、absolute、fixed。还有不常用的：inherit、initial、sticky</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端面试 CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2021/07/28/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/07/28/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1>你好 世界！</h1><p>这是我的第一段代码</p><pre><code class="language-javascript">console.log('Hello World!','你好 世界！');</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
